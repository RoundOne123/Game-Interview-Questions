一、什么时GC？为什么需要GC？
    GC，即垃圾回收，是一种自动内存管理机制。
    自动内存管理机制可以自动的判断指定的内存区域是否需要被释放，安全的释放指定的内存区域。

二、GC算法的分类
1、引用计数GC和追踪式GC
引用计数式：
    通过额外的计数域来实时计算对单个对象的引用次数，当引用次数为0时回收对象。引用计数式GC是实时的。
追踪式：
    在达到GC条件时，通过扫描系统中是否有到对象的引用来判断对象是否存活，然后回收无用对象。

2、保守式GC和精确式GC
保守式：
    不能准确的识别每一个无用对象，但是能保证在不会错误的回收存活的对象的情况下回收一部分无用对象。
    保守式GC并不需要额外的数据来支持查找对对象的引用，它将【所有内存数据假定为指针】，
    通过一些条件来判定这个指针是否是一个合法的对象的引用。
精确式：
    在回收过程中能准确的识别和回收每一个无用对象的GC方式，
    为了准确识别每一个对象的引用，通常要求一些额外的数据，这些数据通常对用户程序是透明的。
个人思考：
    保守式GC的时候，把所有的内存数据当作指针，则可能会出现将int类型的值，当作某个不可达的对象的地址，从而导致不可大对象不被回收。
    而精确式，会确定每个内存数据的类型，从而进行精确的回收。

3、搬迁式GC和非搬迁式GC
搬迁式：
    在GC过程中需要移动对象在内存中位置，移动位置后，将引用更新到新的位置。
非搬迁式：
    在GC过程中不需要移动对象在内存中位置。

4、实时GC和非实时GC
实时GC：
    指不需要停止用户程序的GC方式；
非实时GC：
    在GC执行过程中必须停止用户程序。
个人思考：
    实时、非实时难道不是指，是否当对象未被引用时就立马被回收嘛？

5、渐进式GC和非渐进式GC
渐进式：
    和实时GC一样，不需要中断用户进程，
    不同的是，渐进式GC【不会在对象抛弃时立即回收】占用的内存资源，而是在达成GC条件时统一进行回收操作。

疑问：渐进式、实时、增量GC？这些概念？弄清楚？这些不太清楚。

三、算法解析
1、引用计数式：
    唯一一种不用用到“根引用”概念的GC算法；
优点
    即时回收，对象不再被引用的瞬间就立即被释放掉，
    将内存管理的开销实时的分布在用户程序运行过程中，不会对用户程序造成明显的停顿。

缺点：
    引用计数要求额外的空间来保存计数值；
    修改一个对象的引用时，需要调整对象的引用计数，增加了指针复制的成本，总体开销比追踪式GC大；
    多线程同时对引用计数进行增减时，引用计数的值可能会产生不一致的问题，需要使用并发机制解决，这是一个不小的开销；
    循环引用的是引用计数的最严重的问题。

如何解决循环引用：
->
弱指针解决方案：
    使用两个计数域来计算对对象的引用，一个称为强引用，一个称为弱引用，当强引用计数为0时对象不再可用。
    弱指针算法必须小心的维护弱引用，如果出现两个强互相引用，依然难以避免环形引用问题，虽然出现了一些自动避免环形引用的算法，但依然不完善，没有广泛的应用。


2、追踪式GC
a、标记清除（Mark & Sweep ）算法
    目前公认最有效的GC算法；
    该算法通过搜索整个系统中对对象的引用来检查对象的可达性，以确定对象是否需要回收；
    分为【标记阶段】和【回收阶段】，标记阶段标记出根节点所有可达的节点，清除阶段释放每个未被标记的已分配内存。

GC的过程：
    在收集垃圾时需要中断正常程序（进程的所有线程？）；
    从根引用（寄存器或者程序栈上的引用）出发，遍历有向可达图并作标记（标记阶段），
    然后再遍历一次内存空间，把所有没有标记的对象释放（清除阶段）。

优点：
    相对于引用计数算法，完全不必考虑循环引用问题;
    操纵指针时没有额外的开销；
    与用户进程完全分离。

缺点：
    对内存的回收是非实时的，在GC过程中，要暂停用户程序运行（这对实时和交互式系统的影响非常大）；
    在程序涉及的内存大、对象多时，中断过程可能会比【较长】，尤其在对象大都需要回收时，回收过程可能【消耗】很大；
    保守式的标记清除算法可能会将某些无用对象当作存活对象，导致内存泄漏。

保守式的标记清除算法：
    不能确定一个内存上的数据是否是一个指针，因此不能移动对象的位置。
->
Mono使用的Boehm（贝母）算法就是保守的标记清除算法。


b、标记缩并（Mark & Compaction）
    标记缩并算法就是为了处理内存碎片问题而产生的。
GC的过程：
    中断当前程序；
    标记阶段：标记所有可达的对象；
    缩并阶段：移动对象并且合并空闲区块；
    更新阶段：更新所有到存活对象的引用。

优点：
    相比于基本的标记清除算法，减少了内存碎片，提高了内存分配和访问效率；
    相比于下面要讲的节点复制算法，对内存需求更低。

缺点：
    需要移动对象位置，需要更新所有到对象的引用，因此需要更多的GC时间；
    需要额外的空间保存缩并信息；
    需要精确的识别对象引用，因此需要编译器或框架支持。

具体的实现算法：
-> 双指针算法：
    双指针算法要求每次分配的对象大小必需一样，但是并不需要额外的数据结构来保存节点信息。
这个算法包括【两个指针】，执行过程如下：
（1）：Free指针从堆末尾查找【空闲节点】，Live指针从堆顶查找【存活节点】，
（2）：将Live指针指向的存活节点复制到Free指针指向的空闲节点，将Free指针的地址写入Live指针指向的位置，
（3）：移动Free指针和Live指针，重复（2）直到Free指针和Live指针相遇。

-> 迁徙地址算法：
    迁移地址算法适用于可变大小的内存分配，但是它要求对象中包含一个【记录对象新位置的字段】，并且需要【遍历三次堆】。
三次遍历的执行过程如下：
（1）：第一次从堆头部开始遍历，计算到当前位置遇到的所有存活对象的大小（不包括当前对象），将值记入当前对象的新位置字段。同时将相邻的空闲字段合并成，以减少后面遍历的次数。
（2）：第二次遍历所有的对象，将对其它对象的引用更新到新位置，新位置==当前位置+对象的新位置字段值（此处记录的是不包含当前对象的）。
（3）：第三次移动所有对象到新位置，清除新位置字段的值，为下次收集做准备。


c、节点复制
    通过将所有存活对象从一个区移动到另一个区来过滤非存活对象。    
GC的过程：
    从根节点开始，被引用的对象都会被【复制到】一个新的存储区域中；
    而剩下的对象则是不再被引用的，视为垃圾，留在原来的存储区域；
    释放内存时，直接把原来的存储区域释放掉，继续维护新的存储区域即可。

优点：
    和基本的标记清除算法相比，节点复制算法的开销正比于存活数据的容量（因为只有存活的才需要复制到新的内存中），而不是整个堆的大小；
    较少了内存碎片，有更好的【内存局部性】；
    在大多数对象都需要被回收的情况下，有更高的效率。
    新对象的分配更简洁更高效，并且不需要维护空闲块的列表等辅助数据结构。

缺点：
    相比于标记缩并算法，需要双倍的内存；
    大型对象的复制消耗可能很大。

具体的实现算法：
-> 三色GC算法：
    三色GC算法是【渐进式分代GC算法的基础】。
    它将堆分为两个分区，称为【From区】和【To区】, 每次分配对象分配在From区中，当From区没有可用空间时开始GC，将存活对象从From区复制到To区中，交换From区和To区，新对象的分配只需要在From区已分配的大小加上新对象的大小。
三色GC法将所有对象定义为三种“颜色”：
    黑色：表示当前对象已经被回收器扫描到，并且它的所有引用成员已经被加入到扫描列表中。
    灰色：当前对象已经被加入到扫描列表中，但是还没有被扫描到; 或者被用户程序修改，由黑转灰。后一种情况主要出现在渐进式GC过程中。
    白色：没有扫描到的对象并且也不再队列中，也就是说还没有发现有到该对象的引用。

三色GC算法的实现的两种角度：深度优先、广度优先
-->> 深度优先：
    （对象间的引用关系能让对象迁移到相邻的内存区域，可以获得良好的空间局部性）
执行过程：
（1）：递归的扫描所有根结点，将正在扫描的节点, 从From区复制到To区，在原位置上留下新地址，并标记为灰色。
（2）：扫描这个节点中的所有引用，执行第一步，当这个节点扫描完成后，即所有引用到的成员也已经标记为黑色，将该节点标记为黑色。
（3）：当所有根节点标记为黑色后，剩下的白色节点为可回收块，仍然留在旧From区中，整个旧From区将被回收，所有存活节点密集的分布在To区前部，To区的后部是空闲块，因此不需要维护空闲节点列表。
（4）：交换From和To区。

-->> 广度优先：
执行过程：
（1）：将所有根节点加入扫描队列中，同时将对象从From区移动到To区， 在原位置留下新位置的地址，并将对象标记为灰色。
（2）：从队列头部第一个对象开始扫描，对它的成员进行以下操作：
    如果它是黑色，那么它已经扫描完成了，将当前扫描对象指向它的引用更新到新位置；
    如果它是灰色，那么它已经在To区中了，扫描它的成员，对它的所有成员执行第一步，再将它的颜色转换为黑色。
（3）：当队列头指针和尾指针相等时扫描完成。剩下的白色对象即为可回收块，仍然留在旧From区中，整个旧From区将被回收，所有存活节点紧密的分布在新From区前部，新From区的后部是连续的空闲块，因此不需要维护空闲节点列表。
（3）：交换From和To区


d、分代式GC（Generational Garbage Collection）
    在程序运行过程中，许多对象的生命周期是短暂的，分配不久即被抛弃。
    因此将内存回收的工作焦点集中在这些最有可能是垃圾的对象上，可以提高内存回收的效率，降低回收过程的开销，进而减少对用户程序的中断。
    分代式GC每次回收时通过扫描整个堆中的一部分而是不是全部来降低内存回收过程的开销。

GC的过程：

优点：
    只收集堆的一部分，减少了内存回收的开销，缩短了用户程序的中断时间；
    和节点复制算法相比，只需要和需要回收分区一样大而不是和整个已分配堆一样大的内存。

缺点：
    需要额外的内存空间保存对象的年龄（代）数据；
    为了快速回收年轻年代，必须维护年轻分代的【根节点集合】（这个需要使用拦截器实现，因此需要编译器支持）；
    拦截器的使用增加了指针复制的开销。

实现：
    分代式GC算法基于标记清扫算法或者节点复制算法。


e、渐进式GC
    渐进式GC要解决的问题是如何缩短自动内存管理引起的中断，以降低对实时系统的影响。
    渐进式GC算法基于分代式GC算法，它的核心在于【在用户程序运行过程中维护年轻分代的根结点集合】。

优点：
    可以和用户程序并行执行，对于用户程序影响非常小。

缺点：
    需要编译器支持。

实现：
    在内存回收过程中，将标记阶段分为多段执行，减小用户程序的中断时间。
    在标记过程中，当用户程序修改了对象的引用关系时，GC程序必须知道哪个对象被修改了，以便后面重新标记这个对象。（其他方式的GC不也需要知道吗？其他不是渐进好像不需要，只要在程序中断时，一次性处理就行了？）

基于【记忆集】的渐进式GC算法：

基于卡表法的渐进式GC算法：


https://www.cnblogs.com/superjt/p/5946059.html